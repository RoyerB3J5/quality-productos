---
import Button from '../../components/Button.astro';

type Translations = typeof import('../../i18n/en').default;
type HeroContent = Translations['main']['hero'];
interface Props {
  content: HeroContent;
}
const { content } = Astro.props as Props;

// Personalizar object-position para sm para abajo basado en el sufijo de la URL
const pathname = Astro.url.pathname;
const objectPositions: { [key: string]: string } = {
  'hero-main': 'object-[68%_50%]', 
  'locations-hero': 'object-[62%_50%]',
  'orlando-hero': 'object-[50%_50%]',
  'melbourne-hero': 'object-[60%_50%]',
  'tampa-hero': 'object-[56%_50%]',
  'fort-myers-hero': 'object-[55%_50%]',
  'products-hero': 'object-[50%_50%]',
  'services-hero': 'object-[100%_50%]',
  'industries-hero': 'object-[75%_50%]', 
};
let smallObjectPosition = 'object-[68%_50%]'; // default para otras páginas
for (const [suffix, position] of Object.entries(objectPositions)) {
  if (pathname.endsWith(suffix)) {
    smallObjectPosition = position;
    break;
  }
}
---

<section class="w-full flex items-center justify-center relative overflow-hidden">
  <img
    src={`/images/${content.imagesLoop[0].img}.webp`}
    alt={content.title}
    width="2500"
    height="1563"
    class={`absolute inset-0 w-full h-full object-cover -z-20 sm:object-[50%_65%] 3xl:object-[50%_80%] translate-y-[-20%] sm:translate-y-0 img-hero transition-opacity duration-500 ease-in-out`}
    loading="eager"
    decoding="async"
    id="hero-bg"
    data-images={JSON.stringify(content.imagesLoop.map(img => img.img))}
    data-positions={JSON.stringify(objectPositions)}
  />
  <div class="absolute h-full w-full -z-15 bg-[linear-gradient(180deg,rgba(0,0,0,0.00)_49.08%,#000_80.39%)] sm:bg-none"></div>
  
  <div
    class="w-full max-w-screen md:max-w-7xl flex flex-row justify-start items-end sm:items-center md:items-start gap-4 md:gap-10 px-5 xl:px-0 h-dvh md:h-[90vh] lg:h-screen pt-0 md:pt-[7%] lg:pt-[4%] pb-10 md:pb-0 hero-content"
  >
    <div
      class="flex flex-col items-start justify-center w-full max-w-none lg:max-w-[70%] gap-8 md:gap-4 md:translate-y-10"
    >
      <h1
        class={`text-white sm:text-primary dark:text-paragraph-dark dark:sm:text-primary-dark 
        text-[36px] md:text-[60px] 3xl:text-[64px] 
        font-extrabold leading-[122%] md:leading-[114%] `}
        id="hero-title-main"
        data-services={JSON.stringify(content.services || [])}
      >
        <span set:html={content.title}></span>
        <span class="inline-block overflow-hidden align-top h-[1.2em]" id="service-carousel-container">
          <div id="services-list" class="transition-transform" style="transform: translateY(0)">
            {content.services?.map((service) => (
              <div class="h-[1.2em] leading-[122%] md:leading-[114%] text-accent ">
                {service}
              </div>
            ))}
          </div>
        </span>
      </h1>
      <p class="text-white sm:text-paragraph text-[14px] md:text-[16px] font-normal leading-[143%] md:leading-[150%] max-w-100.25" set:html={content.description}></p>
      <div class="flex justify-between md:justify-start items-center gap-4 w-full md:w-auto">
        {
          content.buttons.map((item)=>( 
            <Button
              text={item.label}
              textClass={item.text}
              href={item.href}
              extraBtnClass={item.back}
              iconName={item.icon}
            />
          ))
        }
      </div>
    </div>
  </div>
</section>

<script is:inline>
  const heroBg = document.getElementById('hero-bg')
  const imagesDataAttr = heroBg?.getAttribute('data-images')
  const positionsDataAttr = heroBg?.getAttribute('data-positions')
  const imagesArray = imagesDataAttr ? JSON.parse(imagesDataAttr) : ['hero-main']
  const positionsMap = positionsDataAttr ? JSON.parse(positionsDataAttr) : {}

  let currentImageIndex = 0
  let isTransitioning = false

  // Convertir clase Tailwind object-[X%_Y%] a CSS válido (X% Y%)
  function convertTailwindToCSS(tailwindClass) {
    if (!tailwindClass) return 'center'
    const match = tailwindClass.match(/object-\[(.*?)\]/)
    if (match) {
      // Convertir 'object-[68%_50%]' → '68% 50%'
      return match[1].replace(/_/g, ' ')
    }
    return 'center'
  }

  // Función para aplicar object-position solo en mobile (sm para abajo)
  function applyObjectPositionIfMobile() {
    const isMobile = window.innerWidth < 640
    if (isMobile && heroBg) {
      const currentImage = imagesArray[currentImageIndex]
      const tailwindPosition = positionsMap[currentImage]
      if (tailwindPosition) {
        const cssPosition = convertTailwindToCSS(tailwindPosition)
        heroBg.style.objectPosition = cssPosition
      }
    } else if (!isMobile && heroBg) {
      // Remover estilos inline en breakpoints grandes para usar clases CSS
      heroBg.style.objectPosition = ''
    }
  }

  // Aplicar object-position en la carga inicial
  applyObjectPositionIfMobile()

  // Cambiar imagen cada 10 segundos
  setInterval(() => {
    if (heroBg && !isTransitioning && imagesArray.length > 0) {
      isTransitioning = true
      
      // Desvanecer la imagen
      heroBg.style.opacity = '0'
      
      // Cambiar la imagen después de que desaparezca
      setTimeout(() => {
        // Incrementar índice PRIMERO
        currentImageIndex = (currentImageIndex + 1) % imagesArray.length
        const newImage = imagesArray[currentImageIndex]
        
        // Cambiar la imagen
        heroBg.src = `/images/${newImage}.webp`
        
        // Aplicar la posición correcta basada en el índice actualizado
        applyObjectPositionIfMobile()
        
        // Mostrar la nueva imagen
        heroBg.style.opacity = '1'
        
        // Fin de transición
        isTransitioning = false
      }, 250)
    }
  }, 10000)

  // Detectar cambios de tamaño y actualizar object-position accordingly
  window.addEventListener('resize', () => {
    applyObjectPositionIfMobile()
  })

  // Efecto Parallax para la sección Hero
  document.addEventListener('DOMContentLoaded', () => {
    const heroBg = document.getElementById('hero-bg');
    const heroSection = heroBg?.closest('section');
    
    if (!heroBg || !heroSection) return;

    window.addEventListener('scroll', () => {
      const scrolled = window.pageYOffset;
      const heroRect = heroSection.getBoundingClientRect();
      
      // Solo aplicar parallax mientras la sección es visible
      if (heroRect.bottom > 0) {
        // Mayor intensidad en mobile para que se vea mejor el efecto
        const isMobile = window.innerWidth < 640
        const parallaxMultiplier = isMobile ? 0.75 : 0.6
        const parallaxValue = scrolled * parallaxMultiplier;
        heroBg.style.transform = `translateY(${parallaxValue}px)`;
      }
    });
  });

  document.addEventListener('DOMContentLoaded', () => {
    const titleElement = document.getElementById('hero-title-main')
    const servicesList = document.getElementById('services-list')
    const serviceContainer = document.getElementById('service-carousel-container')

    const servicesData = titleElement?.getAttribute('data-services')
    const services = servicesData ? JSON.parse(servicesData) : []

    if (services.length === 0 || !servicesList || !serviceContainer) return

    let currentServiceIndex = 0
    const lineHeight = serviceContainer.offsetHeight // Altura de una línea

    // Aplicar transición
    servicesList.style.transition = 'transform 500ms cubic-bezier(0.4, 0, 0.2, 1)'

    setInterval(() => {
      currentServiceIndex = (currentServiceIndex + 1) % services.length
      // Trasladar el contenedor hacia arriba
      servicesList.style.transform = `translateY(-${currentServiceIndex * lineHeight}px)`
    }, 2000)
  })

</script>
